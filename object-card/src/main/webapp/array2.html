<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-language" content="ja">
  <meta charset="UTF-8">
  <script type="text/javascript" src="dwr/engine.js"></script>
  <script type="text/javascript" src="dwr/util.js"></script>
  <script type="text/javascript" src="js/jquery-3.4.1.slim.min.js"></script>
  <script type="text/javascript" src="js/jquery.serialize.js"></script>
  <script type="text/javascript" src="dwr/interface/CardPrinter.js"></script>
  <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
  <style type="text/css">
    body {
      margin: 0;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      /* background-color: white; */
      color: #ffffff;
      width: 500px;
      /* margin: 40% auto; */
      margin-top: 20%;
      /* margin-bottom: 100%; */
      margin-left: 40%;
      margin-right: 40%;
      text-align: center;
    }

    .loader,
    .loader:before,
    .loader:after {
      border-radius: 50%;
      width: 2.5em;
      height: 2.5em;
      -webkit-animation-fill-mode: both;
      animation-fill-mode: both;
      -webkit-animation: load7 1.8s infinite ease-in-out;
      animation: load7 1.8s infinite ease-in-out;
    }

    .loader {
      color: #ffffff;
      font-size: 10px;
      margin: 80px auto;
      position: relative;
      text-indent: -9999em;
      -webkit-transform: translateZ(0);
      -ms-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-animation-delay: -0.16s;
      animation-delay: -0.16s;
    }

    .loader:before,
    .loader:after {
      content: '';
      position: absolute;
      top: 0;
    }

    .loader:before {
      left: -3.5em;
      -webkit-animation-delay: -0.32s;
      animation-delay: -0.32s;
    }

    .loader:after {
      left: 3.5em;
    }

    @-webkit-keyframes load7 {

      0%,
      80%,
      100% {
        box-shadow: 0 2.5em 0 -1.3em;
      }

      40% {
        box-shadow: 0 2.5em 0 0;
      }
    }

    @keyframes load7 {

      0%,
      80%,
      100% {
        box-shadow: 0 2.5em 0 -1.3em;
      }

      40% {
        box-shadow: 0 2.5em 0 0;
      }
    }
  </style>

</head>

<body>
  <div id="modal" class="modal">
    <div class="modal-content">
      <div class="modal-body">
        <h1>相手プレイヤーが操作中です</h1>
        <div class="loader">Loading...</div>
      </div>
    </div>
  </div>
  <p>
    <span id="error_message" class="error"></span>
  </p>

  <script type="text/javascript">

    var config = {
      type: Phaser.AUTO,
      width: 1600,
      height: 800,
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    var field_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" } };
    var p2_field_card = { 1: { HP: 1, ATK: 1, TYPE: "MAG", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" } };

    //instance_cardは最後のインスタン化するときのやつ
    var instance_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" } };
    var p2_instance_card = { 1: { HP: 2, ATK: 2, TYPE: "MAG", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" }, 2: { HP: 1, ATK: 1, TYPE: "MAG", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" }, 3: { HP: 1, ATK: 1, TYPE: "MAG", FLY: 0, PHS: 0, MAG: 0, NAME: "スライム" } };

    var hands_card = { 1: { HP: 1, ATK: 1, TYPE: undefined, NAME: undefined, KIND: "MO" }, 2: { HP: 1, ATK: 1, TYPE: undefined, NAME: undefined, KIND: "MO" }, 3: { HP: 1, ATK: 1, TYPE: undefined, NAME: undefined, KIND: "MO" }, 4: { HP: 1, ATK: 1, TYPE: undefined, NAME: undefined, KIND: "MO" }, 5: { HP: 1, ATK: 1, TYPE: undefined, NAME: undefined, KIND: "MO" } };

    var copy_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" } };
    var p2_copy_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", FLY: 0, PHS: 0, MAG: 0, NAME: "" } };

    var game = new Phaser.Game(config);
    var hand = 3;
    var deck = 30;
    var HP = 10;
    var HPText;
    var set = null;
    var SCText;//場札のどれにsetするかのテキスト
    var WINText;//WINorLOSEのテキスト
    var ErrorText;//Errorのテキスト
    var width = 1600;
    var height = 800;
    var cards = [];
    var dug = hand;
    var count1 = 0;//p1
    var count2 = 0;//p2
    var wins = 0;//連勝数記録
    var STAT_TEXT = [];
    var TYPE_TEXT = [];
    var hands_STAT_TEXT = [];
    var hands_TYPE_TEXT = [];
    var p2_STAT_TEXT = [];
    var p2_TYPE_TEXT = [];
    var end_fin = 0;//お互いがend押したかどうか0か1
    var ready_flag = 0;//ready押したかどうか
    var set_num = "";//どれをインスタンス化するかの数値
    var hand_num = 0;//手札の何枚目を場に出したかがわかる数値
    var end_count = 0;//
    var vslog_TEXT = [];//iは行
    var p2_vslog_TEXT = [];
    var plog_num = 0;//行
    var plog_end = 0;
    var objects = {};
    var status_text = [];
    var buffed = 0;
    var typs = 0;//場札のタイプの数
    var status_max = 0;//今出てるステータスの数
    var capsule_flag = 0;
    var flag = [];
    var st_t = [];//status_log_text
    var capsule_now = 0;
    var capsule_str = "";

    function getUrlVars() {
      var vars = [], max = 0, hash = "", array = "";
      var url = window.location.search;

      //?を取り除くため、1から始める。複数のクエリ文字列に対応するため、&で区切る
      hash = url.slice(1).split('&');
      max = hash.length;
      for (var i = 0; i < max; i++) {
        array = hash[i].split('=');    //keyと値に分割。
        vars.push(array[0]);    //末尾にクエリ文字列のkeyを挿入。
        vars[array[0]] = array[1];    //先ほど確保したkeyに、値を代入。
      }

      return vars;
    }
    var val = getUrlVars();
    console.log(val.player);
    var p2_HP = 10;

    function preload() {
      this.load.image('card', 'img/card.png');
      this.load.image('card2', 'img/card2.png');
      this.load.image('slimc11', 'img/slimee.png');
      this.load.image('magic11', 'img/magg.png');
      this.load.image('phsic11', 'img/phss.png');
      this.load.image('flyic11', 'img/flyy.png');
      this.load.image('gree', 'img/green.png');
      this.load.image('magic12', 'img/Rmag.png');
      this.load.image('magic13', 'img/Bmag.png');
      this.load.image('magic14', 'img/Ymag.png');
      this.load.image('phsic12', 'img/Rphs.png');
      this.load.image('phsic13', 'img/Bphs.png');
      this.load.image('phsic14', 'img/Yphs.png');
      this.load.image('flyic12', 'img/Rfly.png');
      this.load.image('flyic13', 'img/Bfly.png');
      this.load.image('flyic14', 'img/Yfly.png');
      this.load.image('capsule', 'img/capsule.png');

    }

    function cpy(c1, c2) {
      for (var i = 1; i <= 3; i++) {
        c1[i].ATK = c2[i].atk;
        c1[i].HP = c2[i].hp;
        c1[i].NAME = c2[i].name;
        c1[i].FLY = c2[i].fly;
        c1[i].MAG = c2[i].mag;
        c1[i].PHS = c2[i].phs;
        if (c2[i].KIND != null) {
          c1[i].KIND = c2[i].KIND;
        }
      }
    }

    function copy_array(c1, c2) {
      for (var i = 1; i <= 3; i++) {
        c1[i].ATK = c2[i].ATK;
        c1[i].HP = c2[i].HP;
        c1[i].NAME = c2[i].NAME;
        c1[i].FLY = c2[i].FLY;
        c1[i].MAG = c2[i].MAG;
        c1[i].PHS = c2[i].PHS;
        if (c2[i].KIND != null) {
          c1[i].KIND = c2[i].KIND;
        }
      }
    }//前のやつに後ろのやつを入れる

    function hands_kind(s, st) {
      var n = Number(st.slice(6, 7))
      if (n != NaN) {
        if (n <= 9) {
          hands_card[s].KIND = "CP";
          if (n <= 6) {
            hands_card[s].KIND = "OR";
            if (n <= 3) {
              hands_card[s].KIND = "OL";
            }
          }
        }
      }
    }//OLorORorCPのカードにする　カードの出現率にもなってる

    function hands_status(i) {
      var str1 = '' + hands_card[i].NAME;
      console.log(i + "番目のカード:" + str1);
      if (str1.slice(4, 5) == 'c') {
        hands_card[i].ATK = 1;
        hands_card[i].TYPE = "FLY";
      } else if (str1.slice(4, 5) == 'd') {
        hands_card[i].ATK = 2;
        hands_card[i].TYPE = "PHS";
      } else if (str1.slice(4, 5) == 's') {
        hands_card[i].ATK = 3;
        hands_card[i].TYPE = "MAG";
      } else if (str1.slice(4, 5) == 'h') {
        hands_card[i].ATK = 4;
        hands_card[i].TYPE = "FLY";
      }
      if (hands_card[i].KIND == "MO") {
        hands_card[i].HP = Number(2);
      } else {
        hands_card[i].HP = Number(str1.slice(6, 7));
      }
      if (hands_card[i].NAME != null) {
        hands_STAT_TEXT[i].setText(hands_card[i].ATK + ":" + hands_card[i].HP);
        if (hands_card[i].KIND == "MO") {
          hands_TYPE_TEXT[i].setText(hands_card[i].NAME);
        } else {
          hands_TYPE_TEXT[i].setText(hands_card[i].TYPE);
        }
      }
    }

    function status_card(po) {
      for (var i = 1; i <= 5; i++) {
        hands_STAT_TEXT[i] = po.add.text(-40 + i * 120, height / 8 * 7 + 50, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        hands_STAT_TEXT[i].setText("");
        hands_TYPE_TEXT[i] = po.add.text(-30 + i * 120 - 25, height / 8 * 7 - 75, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        hands_TYPE_TEXT[i].setText("");
        hands_status(i);
      }
    }//手札のカードの値をカードの下に表示する？？

    function type_print(a) {
      //console.log("TYPE_PRINT:"+a.NAME);
      if (a.NAME == null) {
        return "gree";
      }
      if (a.NAME != null) {
        if (a.TYPE == "SLIME") {
          return "slimc11";
        } else if (a.TYPE == "FLY") {
          if (a.KIND == "OL") {
            return "flyic12";
          } else if (a.KIND == "OR") {
            return "flyic13";
          } else if (a.KIND == "CP") {
            return "flyic14";
          }
          return "flyic11";
        } else if (a.TYPE == "MAG") {
          if (a.KIND == "OL") {
            return "magic12";
          } else if (a.KIND == "OR") {
            return "magic13";
          } else if (a.KIND == "CP") {
            return "magic14";
          }
          return "magic11";
        } else if (a.TYPE == "PHS") {
          if (a.KIND == "OL") {
            return "phsic12";
          } else if (a.KIND == "OR") {
            return "phsic13";
          } else if (a.KIND == "CP") {
            return "phsic14";
          }
          return "phsic11";
        }
      } else {
        return "gree";
      }
    }

    function create() {
      objects.camera = this.cameras.add(0, 0, 1600, 800);//どっからどこまでカメラ
      objects.camera.setBackgroundColor('rgba(0,255,0, 0.5)');//背景色を帰れるよ

      var x = 1;

      for (var i = 1; i <= 9; i++) {
        cards[x] = 'cardc0' + i;
        x++;
        cards[x] = 'cardd0' + i;
        x++;
        cards[x] = 'cardh0' + i;
        x++;
        cards[x] = 'cards0' + i;
        x++;
      }//make deck1

      for (var i = 10; i <= 13; i++) {
        cards[x] = 'cardc' + i;
        x++;
        cards[x] = 'cardd' + i;
        x++;
        cards[x] = 'cardh' + i;
        x++;
        cards[x] = 'cards' + i;
        x++;
      }//make deck2

      for (i = 0; i < 53; i++) {
        r = Math.floor(Math.random() * 13 * 4);
        w = cards[i];
        cards[i] = cards[r];
        cards[r] = w;
      }//shuffle

      function monster_card(thas) {
        var monster = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "RED", KIND: "MO" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "GREEN", KIND: "MO" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "BLUE", KIND: "MO" } };
        for (var i = 1; i <= hand; i++) {
          hands_card[i] = monster[i];
          card = thas.add.image(-20 + i * 120, height / 8 * 7, type_print(hands_card[i]));
        }
      }

      monster_card(this);
      status_card(this);

      for (var i = 1; i <= 3; i++) {
        STAT_TEXT[i] = this.add.text(180 * i - 45, 450, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        TYPE_TEXT[i] = this.add.text(180 * i - 45, 325, "").setFontSize(20).setFontFamily("Arial").setOrigin(0).setInteractive();
        STAT_TEXT[i].setText(field_card[i].ATK + ":" + field_card[i].HP);
        TYPE_TEXT[i].setText(field_card[i].NAME);//動くの？？
        p2_STAT_TEXT[i] = this.add.text(80 + i * 120, 150, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        p2_TYPE_TEXT[i] = this.add.text(80 + i * 120 - 25, 25, "").setFontSize(20).setFontFamily("Arial").setOrigin(0).setInteractive();
        p2_STAT_TEXT[i].setText(p2_field_card[i].ATK + ":" + p2_field_card[i].HP);
        p2_TYPE_TEXT[i].setText(p2_field_card[i].NAME);
      }//typeと数値を出すp1とp2 場札

      deck = this.add.image(700, height / 8 * 2, 'card');
      text = this.add.text(680, 150, '山札');

      SCText = this.add.text(300, 250, 'SET:' + set).setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      p2_HPText = this.add.text(650, 300, '2P HP:' + p2_HP).setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      HPText = this.add.text(650, 450, '1P HP:' + HP).setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      WINText = this.add.text(450, 250, '').setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      ErrorText = this.add.text(200, 550, '').setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      instanText = this.add.text(100, 500, '').setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();

      for (var i = 1; i <= 8; i++) {
        status_text[i] = this.add.text(900, height / 2 + 40 * i, "").setInteractive();
      }
    }
    function p2_result(p2_result_data) {
      if (p2_result_data[1].result == 1) {
        if (wins >= 1) {
          wins++;
          WINText.setText('WINS:' + wins);
        } else {
          wins = 1;
          WINText.setText('WIN');
          //resultdbに投げる数字(1);p1が勝つと1,p2が勝つと2 resuletっていう別テーブルを作ってHPと勝ち負けを記録
        }
        p2_HP--;
        updatePlayer("" + 1, HP, 1);
        updatePlayer("" + 2, p2_HP, 2);
        if (p2_HP == 1) {
          ErrorText.setText('YOU WIN');
        }
      } else if (p2_result_data[1].result == 2) {
        WINText.setText('LOSE');
        //resultdbに投げる数字(2);
        if (HP == 1) {
          ErrorText.setText('YOU LOSE');
        }
        HP -= 1;
        updatePlayer("" + 1, HP, 2);
        updatePlayer("" + 2, p2_HP, 1);
      } else {
        WINText.setText('Draw');
        updatePlayer("" + 1, HP, 3);
        updatePlayer("" + 2, p2_HP, 3);
      }
      HP = p2_result_data[1].plyHP;
      p2_HP = p2_result_data[0].plyHP;
      HPText.setText('1P HP' + HP);
      p2_HPText.setText('2P HP' + p2_HP);
    }//p1が勝つとwin,p2が勝つとlose // p2がdataを受け取って表示するためのデータ


    function result(count1, count2) {
      updatePlayer("" + 1, HP, 0);
      updatePlayer("" + 2, p2_HP, 0);
      if (count2 > count1) {
        if (wins >= 1) {
          wins++;
          WINText.setText('WINS:' + wins);
        } else {
          wins = 1;
          WINText.setText('WIN');
        }
        p2_HP--;
        updatePlayer("" + 1, HP, 1);
        updatePlayer("" + 2, p2_HP, 2);
        if (p2_HP == 1) {
          ErrorText.setText('YOU WIN');
        }
      } else if (count1 > count2) {
        WINText.setText('LOSE');
        if (HP == 1) {
          ErrorText.setText('YOU LOSE');
        }
        HP -= 1;
        updatePlayer("" + 1, HP, 2);
        updatePlayer("" + 2, p2_HP, 1);

      } else {
        WINText.setText('Draw');

        updatePlayer("" + 1, HP, 3);
        updatePlayer("" + 2, p2_HP, 3);
      }
      // selectPlayer();
      HPText.setText('1P HP' + HP);
      p2_HPText.setText('2P HP' + p2_HP);
    }



    function print_log_ref() {
      for (var i = 1; i < plog_num; i++) {
        vslog_TEXT[i].setText("");
      }
      plog_num = 0;
    }

    function print_log(po, r1, r2, k, a, c) {
      if (plog_end == 1) {
        print_log_ref();
        plog_end = 0;
      }
      vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      p2_vslog_TEXT[plog_num] = "p1の" + instance_card[r1].NAME + "[" + instance_card[r1].TYPE + "] VS p2の" + p2_instance_card[r2].NAME + "[" + p2_instance_card[r2].TYPE + "]";
      vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      console.log("****************" + p2_vslog_TEXT[plog_num]);
      plog_num++;
      if (k == 1) {
        vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive().setFill("white");
        p2_vslog_TEXT[plog_num] = "引き分け";
        vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      } else if (k == 2) {
        vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive().setFill("blue");
        //p2_vslog_TEXT[plog_num]="p2の"+p2_instance_card[r2].NAME+"["+p2_instance_card[r2].ATK+":"+p2_instance_card[r2].HP+"]の勝利";
        p2_vslog_TEXT[plog_num] = "p2の" + p2_instance_card[r2].NAME + "[" + p2_instance_card[r2].TYPE + "]の勝利";

        vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      } else if (k == 3) {
        vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive().setFill("red");
        p2_vslog_TEXT[plog_num] = "p1の" + instance_card[r1].NAME + "[" + instance_card[r1].TYPE + "]の勝利";
        vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      }
      updateLog(p2_vslog_TEXT);
      plog_num++;
    }//戦闘のログを実際に画面に表示する？

    async function p2_print_log(po) {
      if (plog_end == 1) {
        print_log_ref();
        plog_end = 0;
      }
      if (val.player == 2) {
        p2_vslog_TEXT = (await selectLog()).map(({ log }) => log);
        for (var i = 0; i < 3; i++) {
          vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
          vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
          plog_num++;
          vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
          vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
          plog_num++;
        }
      }
    }//戦闘のログを実際に画面に表示する？

    function print_type_text(a) {
      typs = 0;
      if (a.FLY == 1) {
        typs++;
      }
      if (a.MAG == 1) {
        typs++
      }
      if (a.PHS == 1) {
        typs++;
      }
    }

    function type_rndm_select(a) {
      const types = ["FLY", "MAG", "PHS"].filter(type => a[type] === 1)
      return types[Math.floor(Math.random() * types.length)] || null
    }





    function duel(f, p2_f, po) {
      var cnum = 0;
      while ((count1 != 3 && count2 != 3) && cnum++ != 100) {
        var r1 = Math.floor(Math.random() * 3 + 1);
        var r2 = Math.floor(Math.random() * 3 + 1);
        if (f[r1].HP > 0 && p2_f[r2].HP > 0) {
          console.log("f[" + r1 + "]" + "VS" + "p2_f[" + r2 + "]");
          f[r1].TYPE = type_rndm_select(f[r1]);
          p2_f[r2].TYPE = type_rndm_select(p2_f[r2]);
          console.log(p2_f[r2]);
          if (f[r1].TYPE != p2_f[r2].TYPE) {
            f[r1].HP -= p2_f[r2].ATK;
            p2_f[r2].HP -= f[r1].ATK;
          }

          // f[r1].HP -= p2_f[r2].ATK;
          // p2_f[r2].HP -= f[r1].ATK;

          if (f[r1].HP <= 0 && p2_f[r2].HP <= 0) {
            console.log("Draw");
            count1++;
            count2++;
            print_log(po, r1, r2, 1, f, p2_f);
          } else {
            if (f[r1].HP <= 0) {
              count1++;//カードが倒されたp1の
              console.log("p2_f[" + r2 + "]の勝利");
              print_log(po, r1, r2, 2, f, p2_f);
            }
            if (p2_f[r2].HP <= 0) {
              count2++;//カードが倒されたp2の
              console.log("f[" + r1 + "]の勝利");
              print_log(po, r1, r2, 3, f, p2_f);
            }
          }
        }
        console.log('count1:' + count1);
        console.log('count2:' + count2);
      }
      result(count1, count2);
    }//p1からp2への戦い一方的
    //今p2の場札1を1.1じゃなくて2.2にしてるよ

    function buff() {
      console.log("もとのやつ:" + field_card[set].ATK + "," + field_card[set].HP);
      console.log("足した奴:" + hands_card[hand_num].ATK + "," + hands_card[hand_num].HP);
      field_card[set].ATK += hands_card[hand_num].ATK;
      field_card[set].HP += hands_card[hand_num].HP;
      console.log("ATK合計:" + field_card[set].ATK);
      console.log("HP合計:" + field_card[set].HP);
    }

    function overload() {
      if (hands_card[hand_num].TYPE == "FLY") {
        field_card[set].FLY = 1;
      } else if (hands_card[hand_num].TYPE == "MAG") {
        field_card[set].MAG = 1;
      } else if (hands_card[hand_num].TYPE == "PHS") {
        field_card[set].PHS = 1;
      }
    }//オーバーロードカードの動き

    function override() {
      var ch = 0;
      if (field_card[set].FLY == 1 && hands_card[hand_num].TYPE == "FLY") {
        ch = 1;
      } else if (field_card[set].MAG == 1 && hands_card[hand_num].TYPE == "MAG") {
        ch = 1;
      } else if (field_card[set].PHS == 1 && hands_card[hand_num].TYPE == "PHS") {
        ch = 1;
      }
      if (ch == 1) {
        field_card[set].HP *= 2;
        ErrorText.setText('オーバーライドしました');
        return 1;
      } else {
        return 0;
      }
    }

    function overrideold() {
      if (hands_card[hand_num].TYPE == field_card[set].TYPE) {
        field_card[set].HP *= 2;
        ErrorText.setText('オーバーライドしました');
        return 1;
      } else {
        return 0;
      }
    }

    function capsule(ps) {
      for (var i = 1; i <= status_max - 1; i++) {
        flag[i] = 1;
        //status_text[i]=ps.add.text(900-20,height/2+40*i,""+flag[i]).setInteractive();
      }
      status_max = 0;
      instanText.setText("どれをカプセル化しますか");
    }//カプセル化

    function inheri_check() {
      if (field_card[set].NAME == "GREENスライム") {
        return 1;
      } else if (field_card[set].NAME == "REDスライム") {
        return 1;
      } else if (field_card[set].NAME == "BLUEスライム") {
        return 1;
      } else {
        return 0;
      }
    }

    function replen_card(p) {
      for (var i = hand + 1; i <= 5; i++) {
        hand++;
        dug++;//掘り進めた数
        hands_card[i].NAME = '' + String(cards[dug]);
        hands_kind(i, hands_card[i].NAME);
        hands_status(i);
        console.log(hands_card[i]);
      }
    }//カードの補充

    function capsule_cap(k) {
      var capsule_str = "" + st_t[k];
      if (capsule_str == "FLY") {
        field_card[set].FLY = 0;
      } else if (capsule_str == "MAG") {
        field_card[set].MAG = 0;
      } else if (capsule_str == "PHS") {
        field_card[set].PHS = 0;
      }
      for (var i = 1; i <= typs * 2; i++) {
        flag[i] = 0;
      }
      for (var i = k; i <= typs * 2; i++) {
        status_text[i].setText("");
        status_text[i] = status_text[i + 1];
      }
      print_type_text(field_card[set]);


      ErrorText.setText("カプセル化:" + capsule_str);
    }//どれをカプセル化するかのとこ

    function print_TEXT() {
      for (i = 1; i <= 3; i++) {
        p2_STAT_TEXT[i].setText(p2_field_card[i].ATK + ":" + p2_field_card[i].HP);
        p2_TYPE_TEXT[i].setText(p2_field_card[i].NAME);
        STAT_TEXT[i].setText(field_card[i].ATK + ":" + field_card[i].HP);
        TYPE_TEXT[i].setText(field_card[i].NAME);
      }//p2 dbから帰ってきたようのやつ
      for (i = 1; i <= hand; i++) {
        hands_STAT_TEXT[i].setText(hands_card[i].ATK + ":" + hands_card[i].HP);
        if (hands_card[i].KIND == "MO") {
          hands_TYPE_TEXT[i].setText(hands_card[i].NAME);
        } else {
          hands_TYPE_TEXT[i].setText(hands_card[i].TYPE);
        }
      }//手札の情報
    }

    function status_log(pa) {
      var check_card = [];
      var c = hand_num;

      if (status_text[0] != null) {
        for (var i = 0; i <= typs * 2; i++) {
          status_text[i].setText("");
        }
      }//reset status_log
      var i = 0;
      if (inheri_check() == 0) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "");
        status_text[i].setText("継承:" + field_card[set].NAME + "(" + field_card[set].TYPE + ")");
        i++;
      } else {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "");
        status_text[i].setText("継承:" + field_card[set].NAME + "(" + field_card[set].TYPE + ")<-" + copy_card[set].NAME + "(" + copy_card[set].TYPE + ")");
        i++;
      }
      print_type_text(field_card[set]);
      if (field_card[set].FLY == 1) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "").setInteractive();
        st_t[i] = "FLY";
        status_text[i].setText("int attack(" + st_t[i] + ")");
        i++;
      }
      if (field_card[set].MAG == 1) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "").setInteractive();
        st_t[i] = "MAG";
        status_text[i].setText("int attack(" + st_t[i] + ")");
        i++;
      }
      if (field_card[set].PHS == 1) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "").setInteractive();
        st_t[i] = "PHS";
        status_text[i].setText("int attack(" + st_t[i] + ")");
        i++;
      }
      if (field_card[set].FLY == 1) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "").setInteractive();
        st_t[i] = "FLY";
        status_text[i].setText("int deffence(" + st_t[i] + ")");
        i++;
      }
      if (field_card[set].MAG == 1) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "").setInteractive();
        st_t[i] = "MAG";
        status_text[i].setText("int deffence(" + st_t[i] + ")");
        i++;
      }
      if (field_card[set].PHS == 1) {
        status_text[i] = pa.add.text(900, height / 2 + 40 * i, "").setInteractive();
        st_t[i] = "PHS";
        status_text[i].setText("int deffence(" + st_t[i] + ")");
        i++;
      }
      status_max = i;
    }//beta status_log

    function update_hands() {
      hand--;
      for (var i = hand_num; i <= hand; i++) {
        hands_card[i].NAME = hands_card[i + 1].NAME;
        hands_card[i].KIND = hands_card[i + 1].KIND;
        hands_card[i].TYPE = hands_card[i + 1].TYPE;
        hands_status(i);
      }
      hands_STAT_TEXT[hand + 1].setText("");
      hands_TYPE_TEXT[hand + 1].setText("");
      hands_card[hand + 1].NAME = null;
      console.log(hands_card);
    }//手札の順番ソート

    function inheri() {
      buff();
      buffed = 1;
      field_card[set].NAME = hands_card[hand_num].NAME + field_card[set].NAME;
      update_hands();
    }//継承

    function instance(str) {
      j = 1;
      for (var i = 2; i <= 6; i = i + 2) {
        instance_card[j] = field_card[str.slice(i - 1, i)];
        console.log("strslice" + i + ":" + str.slice(i - 1, i));
        j++;
      }
    }//インスタンス

    function print() {
      for (i = 1; i <= 3; i++) {
        console.log("f1[" + i + ":" + field_card[i].HP + ":" + field_card[i].ATK);
        console.log("f2[" + i + ":" + p2_field_card[i].HP + ":" + p2_field_card[i].ATK);
        console.log("instance_Card[" + i + "]:" + instance_card[i].HP + ":" + instance_card[i].ATK);
        console.log("p2_instance_Card[" + i + "]:" + p2_instance_card[i].HP + ":" + p2_instance_card[i].ATK);
      }
    }

    function refresh() {
      resetResult("" + val.player);
      ready_flag = 0;
      set_num = "";
      instanText.setText("");
      count1 = 0;
      count2 = 0;
      plog_end = 1;
    }

    function ready_set() {
      if (ready_flag >= 1 && ready_flag < 4) {
        set_num = set_num + " " + set;
        ErrorText.setText("順番:" + set_num);
        ready_flag++;
      } else if (ready_flag >= 4) {
        ready_flag = 1;
        set_num = "";
        ErrorText.setText("順番:" + set_num);
      }
    }

    function TYPE_CHECK(ty, p) {
      var t = "";
      if (ty == "MAG") {
        field_card[set].MAG = 1;
        t += "魔法";
      } else if (ty == "FLY") {
        field_card[set].FLY = 1;
        t += "飛行";
      } else if (ty == "PHS") {
        field_card[set].PHS = 1;
        t += "物理";
      }
      ErrorText.setText(t + 'をオーバーロードしました');
    }

    function card_deal(po) {
      if (set != null && hands_card[hand_num].NAME != "gree" && hands_card[hand_num].NAME != null) {
        var okor = 1;
        if (inheri_check() == 1) {
          if (hands_card[hand_num].KIND == "CP") {
            capsule_now = 1;
            capsule(po);
            buff();
            buffed = 1;
            update_hands();
          } else {
            if (hands_card[hand_num].KIND == "OL") {
              field_card[set].TYPE = hands_card[hand_num].TYPE;
              overload();
              TYPE_CHECK(field_card[set].TYPE, po);
            } else if (hands_card[hand_num].KIND == "OR") {
              if (okor = override()) {
                field_card[set].TYPE = hands_card[hand_num].TYPE;
              }
            }
            if (okor == 1) {
              buff();
              buffed = 1;
              update_hands();
            } else {
              ErrorText.setText('タイプが違うと,オーバーロードできません');
            }
          }
        } else if (hands_card[hand_num].KIND == "MO") {
          inheri();

        } else if (hands_card[hand_num].KIND != "MO") {
          ErrorText.setText('継承していないとオーバーライド,オーバーロードできません');
        }
      } else if (set == null) {
        ErrorText.setText("場にある継承元を選んでください");
      }
    }

    function capsule_print(l) {
      if (flag[l] == 1) {
        return "+";
      } else {
        return "";
      }
    }

    function update() {
      let draw = this.add.text(800, 400, 'Draw').setFontSize(30).setFontFamily("Arial").setOrigin(0.5).setInteractive();
      let end = this.add.text(700, 400, 'End').setFontSize(30).setFontFamily("Arial").setOrigin(0.5).setInteractive();
      let ready = this.add.text(150, 300, 'インスタンス').setFontSize(30).setFontFamily("Arial").setOrigin(0.5).setInteractive();
      let card1 = this.add.image(100, height / 8 * 7, type_print(hands_card[1])).setOrigin(0.5).setInteractive();
      let card2 = this.add.image(220, height / 8 * 7, type_print(hands_card[2])).setOrigin(0.5).setInteractive();
      let card3 = this.add.image(340, height / 8 * 7, type_print(hands_card[3])).setOrigin(0.5).setInteractive();
      let card4 = this.add.image(460, height / 8 * 7, type_print(hands_card[4])).setOrigin(0.5).setInteractive();
      let card5 = this.add.image(580, height / 8 * 7, type_print(hands_card[5])).setOrigin(0.5).setInteractive();
      let slime1 = this.add.image(160, height / 2, type_print(field_card[1])).setInteractive();
      let slime2 = this.add.image(340, height / 2, type_print(field_card[2])).setInteractive();
      let slime3 = this.add.image(520, height / 2, type_print(field_card[3])).setInteractive();
      let p2_field_card1 = this.add.image(-20 + 2 * 120, height / 8, type_print(p2_field_card[1])).setInteractive();
      let p2_field_card2 = this.add.image(-20 + 3 * 120, height / 8, type_print(p2_field_card[2])).setInteractive();
      let p2_field_card3 = this.add.image(-20 + 4 * 120, height / 8, type_print(p2_field_card[3])).setInteractive();
      let status1 = this.add.text(900 - 20, height / 2 + 40 * 1, capsule_print(1)).setInteractive();
      let status2 = this.add.text(900 - 20, height / 2 + 40 * 2, capsule_print(2)).setInteractive();
      let status3 = this.add.text(900 - 20, height / 2 + 40 * 3, capsule_print(3)).setInteractive();
      let status4 = this.add.text(900 - 20, height / 2 + 40 * 4, capsule_print(4)).setInteractive();
      let status5 = this.add.text(900 - 20, height / 2 + 40 * 5, capsule_print(5)).setInteractive();
      let status6 = this.add.text(900 - 20, height / 2 + 40 * 6, capsule_print(6)).setInteractive();
      SCText.setText('SET:' + set);//出したいカードの場所テキスト
      deck = this.add.image(700, height / 8 * 6, 'card').setInteractive();//山札クリックしてもドローできるよ
      text = this.add.text(680, 550, '山札');
      print_TEXT();
      if (set != null) {
        status_log(this);
      }

      status1.on('pointerdown', function (pointer) {
        capsule_cap(1);
      }, this);

      status2.on('pointerdown', function (pointer) {
        capsule_cap(2);
      }, this);

      status3.on('pointerdown', function (pointer) {
        capsule_cap(3);
      }, this);

      status4.on('pointerdown', function (pointer) {
        capsule_cap(4);
      }, this);

      status5.on('pointerdown', function (pointer) {
        capsule_cap(5);
      }, this);

      status6.on('pointerdown', function (pointer) {
        capsule_cap(6);
      }, this);

      ready.on('pointerdown', function (pointer) {
        instanText.setText("どれを戦闘に参加させますか？(インスタンス化)");
        ErrorText.setText("順番:" + set_num);
        ready_flag = 1;
      }, this);

      end.on('pointerdown', function (pointer) {
        var k = this;
        console.log("end:" + field_card);
        if (ready_flag != 4) {
          ErrorText.setText("インスタンスを押してインスタンス化してください");
        } else {
          instance(set_num);
          console.log("instance_card:" + instance_card);
          print();
          copy_array(copy_card, field_card);
          copy_array(p2_copy_card, p2_instance_card);

          var pa = this;
          if (val.player == 1) {
            updateField(instance_card, "" + val.player, 1, 1);
            document.getElementById("modal").style.display = "inline";
            var end_fin = setInterval(function () {
              selectHand2();
              if (end111 == 1 && end222 == 1) {
                getP2Hand().then(field_inf => {
                  const p2hand_inf = [null, ...field_inf];
                  console.log(p2hand_inf);
                  cpy(p2_instance_card, p2hand_inf);
                  console.log(p2_instance_card);
                  document.getElementById("modal").style.display = "none";
                  clearInterval(end_fin);
                  end_fin = 0;
                  if (val.player == 1) {
                    duel(instance_card, p2_instance_card, pa);
                  }
                  copy_array(field_card, copy_card);
                  copy_array(p2_instance_card, p2_copy_card);
                  refresh();

                });
              }
            }, 1000);
          } else {
            updateField2(instance_card, "" + val.player, 1, 0);
            document.getElementById("modal").style.display = "inline";
            var end_fin = setInterval(async function () {
              selectHand();
              const p2_result_data = await selectPlayer();
              //result222=0じゃなくなる関数
              console.log("*********" + p2_result_data);
              if (end111 == 1 && end222 == 1) {
                getP1Hand().then(field_inf => {
                  const p1hand_inf = [null, ...field_inf];
                  cpy(p2_instance_card, p1hand_inf);//p1のハンドコピー
                  document.getElementById("modal").style.display = "none";
                  clearInterval(end_fin);
                  end_fin = 0;
                  p2_print_log(k);
                  p2_result(p2_result_data);
                  //selecthand(); p1のもってくるやつ
                  copy_array(field_card, copy_card);
                  copy_array(p2_instance_card, p2_copy_card);
                  refresh();
                });
              }
            }, 1000);
          }

        }
        //refresh();
      }, this);

      slime1.on('pointerdown', function (pointer) {
        set = 1;
        ready_set();
        if (buffed == 0) {
          copy_array(copy_card, field_card);
        }
        //status_log(this);
      }, this);//場にあるひな形スライムの１個目

      slime2.on('pointerdown', function (pointer) {
        set = 2;
        ready_set();
        if (buffed == 0) {
          copy_array(copy_card, field_card);
        }
        //status_log(this);
      }, this);

      slime3.on('pointerdown', function (pointer) {
        set = 3;
        ready_set();
        if (buffed == 0) {
          copy_array(copy_card, field_card);
        }
        //status_log(this);
      }, this);

      draw.on('pointerdown', function (pointer) {
        if (hand < 5) {
          hand++;
          dug++;//掘り進めた数
          hands_card[hand].NAME = '' + String(cards[dug]);
          hands_kind(hand, hands_card[hand].NAME);
          hands_status(hand);
          card6 = this.add.image(-20 + hand * 120, height / 8 * 7, type_print(hands_card[hand]));
        }
        console.log(hands_card[hand]);
      }, this);//draw　手札上限五枚で五枚以上はドローできない

      deck.on('pointerdown', function (pointer) {
        if (hand < 5) {
          replen_card(this);
        }
        console.log(hands_card);
      }, this);//draw　手札上限五枚で五枚以上はドローできない

      card5.on('pointerdown', function (pointer) {
        hand_num = 5;
        card_deal(this);
      }, this);

      card4.on('pointerdown', function (pointer) {
        hand_num = 4;
        card_deal(this);
      }, this);

      card3.on('pointerdown', function (pointer) {
        hand_num = 3;
        card_deal(this);
      }, this);

      card2.on('pointerdown', function (pointer) {
        hand_num = 2;
        card_deal(this);
      }, this);

      card1.on('pointerdown', function (pointer) {
        hand_num = 1;
        card_deal(this);
      }, this);//一番左出す
    }

    function getP1Hand() {
      return new Promise((resolve, reject) => {
        CardPrinter.execute({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
    }

    function getP2Hand() {
      return new Promise((resolve, reject) => {
        CardPrinter.execute2({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
    }

    function selectHand() {
      CardPrinter.execute({
        callback: function (data) {
          $('#error_message').text("");

          end111 = data.some(({ endcheck }) => endcheck === 1) ? 1 : 0;
        },
        errorHandler: updateErrorMessage
      });
    }

    function selectHand2() {
      CardPrinter.execute2({
        callback: function (data) {
          $('#error_message').text("");

          end222 = data.some(({ endcheck2 }) => endcheck2 === 1) ? 1 : 0;
        },
        errorHandler: updateErrorMessage
      });
    }

    function selectPlayer() {
      return new Promise((resolve, reject) => {
        CardPrinter.plyexe({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
    }

    function selectLog() {
      return new Promise((resolve, reject) => {
        CardPrinter.logexe({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
      // CardPrinter.logexe({
      //   callback: function (logdata) {
      //     $('#error_message').text("");

      //     //data.forEach(function (food) {
      //     //  food_text = food_text + "[name]" + food.name + "[price]" + food.price + "<br/>";
      //     //});

      //   },
      //   errorHandler: updateErrorMessage
      // });
    }

    function updateErrorMessage(message, exception) {
      $('#error_message').text(message);
      $('#pprinterReply').text("");
    }

    function updateField(arr, ply, end, res) {
      var field_inf = {
        "id": 1, "player": ply, "endcheck": end, "result": res,
        "hp": [arr[1].HP, arr[2].HP, arr[3].HP],
        "atk": [arr[1].ATK, arr[2].ATK, arr[3].ATK],
        "type": [arr[1].TYPE, arr[2].TYPE, arr[3].TYPE],
        "fly": [arr[1].FLY, arr[2].FLY, arr[3].FLY],
        "phs": [arr[1].PHS, arr[2].PHS, arr[3].PHS],
        "mag": [arr[1].MAG, arr[2].MAG, arr[3].MAG]
      };
      end111 = 1;
      CardPrinter.updateField(field_inf, {
        callback: function () {
          console.log("updateField実行完了")
        },
        errorHandler: updateErrorMessage
      });
    }

    function updateField2(arr, ply, end2, res2) {
      var field_inf = {
        "id": 1, "player": ply, "endcheck2": end2, "result2": res2,
        "hp": [arr[1].HP, arr[2].HP, arr[3].HP],
        "atk": [arr[1].ATK, arr[2].ATK, arr[3].ATK],
        "type": [arr[1].TYPE, arr[2].TYPE, arr[3].TYPE],
        "fly": [arr[1].FLY, arr[2].FLY, arr[3].FLY],
        "phs": [arr[1].PHS, arr[2].PHS, arr[3].PHS],
        "mag": [arr[1].MAG, arr[2].MAG, arr[3].MAG]
      };
      end222 = 1;
      CardPrinter.updateField2(field_inf, {
        callback: function () {
          console.log("updateField2実行完了");
        },
        errorHandler: updateErrorMessage
      });
    }

    function updatePlayer(ply, plyHP, result) {
      var player_inf = {
        "player": ply, "plyHP": plyHP, "result": result,
      };
      CardPrinter.updatePlayer(player_inf, {
        callback: function () {
          console.log("updatePlayer実行完了");
        },
        errorHandler: updateErrorMessage
      });
    }

    function updateLog(log) {
      console.log("updateLog:" + log);
      var log_inf = {
        "logid": 1, "log": [log[0], log[1], log[2], log[3], log[4], log[5]]
      };
      CardPrinter.updateLog(log_inf, {
        callback: function () {
          console.log("updateLog実行完了");
        },
        errorHandler: updateErrorMessage
      });
    }

    function resetResult(ply) {
      var reset_inf = {
        "player": ply, "endcheck": 0, "result": 0
      };
      CardPrinter.resetResult(reset_inf, {
        callback: function () {
          console.log("resetResult実行完了")
        },
        errorHandler: updateErrorMessage
      });
      CardPrinter.resetResult2(reset_inf, {
        callback: function () {
          console.log("resetResult2実行完了")
        },
        errorHandler: updateErrorMessage
      });
      if (ply == 1) {
        end111 = 0;
      } else {
        end222 = 0;
      }
    }

  </script>


</body>

</html>
