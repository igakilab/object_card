<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-language" content="ja">
  <meta charset="UTF-8">
  <script type="text/javascript" src="dwr/engine.js"></script>
  <script type="text/javascript" src="dwr/util.js"></script>
  <script type="text/javascript" src="js/jquery-3.4.1.slim.min.js"></script>
  <script type="text/javascript" src="js/jquery.serialize.js"></script>
  <script type="text/javascript" src="dwr/interface/CardPrinter.js"></script>
  <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
  <style type="text/css">
    body {
      margin: 0;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      /* background-color: white; */
      color: #ffffff;
      width: 500px;
      /* margin: 40% auto; */
      margin-top: 20%;
      /* margin-bottom: 100%; */
      margin-left: 40%;
      margin-right: 40%;
      text-align: center;
    }

    .loader,
    .loader:before,
    .loader:after {
      border-radius: 50%;
      width: 2.5em;
      height: 2.5em;
      -webkit-animation-fill-mode: both;
      animation-fill-mode: both;
      -webkit-animation: load7 1.8s infinite ease-in-out;
      animation: load7 1.8s infinite ease-in-out;
    }

    .loader {
      color: #ffffff;
      font-size: 10px;
      margin: 80px auto;
      position: relative;
      text-indent: -9999em;
      -webkit-transform: translateZ(0);
      -ms-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-animation-delay: -0.16s;
      animation-delay: -0.16s;
    }

    .loader:before,
    .loader:after {
      content: '';
      position: absolute;
      top: 0;
    }

    .loader:before {
      left: -3.5em;
      -webkit-animation-delay: -0.32s;
      animation-delay: -0.32s;
    }

    .loader:after {
      left: 3.5em;
    }

    @-webkit-keyframes load7 {

      0%,
      80%,
      100% {
        box-shadow: 0 2.5em 0 -1.3em;
      }

      40% {
        box-shadow: 0 2.5em 0 0;
      }
    }

    @keyframes load7 {

      0%,
      80%,
      100% {
        box-shadow: 0 2.5em 0 -1.3em;
      }

      40% {
        box-shadow: 0 2.5em 0 0;
      }
    }
  </style>

</head>

<body>
  <div id="modal" class="modal">
    <div class="modal-content">
      <div class="modal-body">
        <h1>相手プレイヤーが操作中です</h1>
        <div class="loader">Loading...</div>
      </div>
    </div>
  </div>
  <p>
    <span id="error_message" class="error"></span>
  </p>

  <script type="text/javascript">

    var config = {
      type: Phaser.AUTO,
      width: 1600,
      height: 800,
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    //ff_cardはバフするときの途中に使うやつ
    var ff_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };
    var p2_ff_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };

    //instance_cardは最後のインスタン化するときのやつ
    var instance_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };
    var p2_instance_card = { 1: { HP: 2, ATK: 2, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };

    var hands_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 4: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 5: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };

    var copy_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };
    var p2_copy_card = { 1: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 2: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" }, 3: { HP: 1, ATK: 1, TYPE: "SLIME", NAME: "" } };

    var game = new Phaser.Game(config);
    var hand = 5;
    var deck = 30;
    var HP = 10;
    var HPText;
    var set = null;
    var SCText;//場札のどれにsetするかのテキスト
    var WINText;//WINorLOSEのテキスト
    var ErrorText;//Errorのテキスト
    var width = 1600;
    var height = 800;
    var cards = [];
    var hands = [];
    var dug = hand;
    var field_card = [];//p1の場札のカードの表示
    var p2_field_card = [];//p2の場札のカードの表示
    var count1 = 0;//p1
    var count2 = 0;//p2
    var wins = 0;//連勝数記録
    var STAT_TEXT = [];
    var TYPE_TEXT = [];
    var hands_STAT_TEXT = [];
    var hands_TYPE_TEXT = [];
    var p2_STAT_TEXT = [];
    var p2_TYPE_TEXT = [];
    var end_fin = 0;//お互いがend押したかどうか0か1
    var ready_flag = 0;//ready押したかどうか
    var set_num = "";//どれをインスタンス化するかの数値
    var hand_num = 0;//手札の何枚目を場に出したかがわかる数値
    var end_count = 0;//
    var vslog_TEXT = [];//iは行？
    var plog_num = 0;//行
    var plog_end = 0;
    var objects = {};
    var end111 = 0;
    var end222 = 0;
    var p2_vslog_TEXT = [];

    function getUrlVars() {
      var vars = [], max = 0, hash = "", array = "";
      var url = window.location.search;

      //?を取り除くため、1から始める。複数のクエリ文字列に対応するため、&で区切る
      hash = url.slice(1).split('&');
      max = hash.length;
      for (var i = 0; i < max; i++) {
        array = hash[i].split('=');    //keyと値に分割。
        vars.push(array[0]);    //末尾にクエリ文字列のkeyを挿入。
        vars[array[0]] = array[1];    //先ほど確保したkeyに、値を代入。
      }

      return vars;
    }


    var val = getUrlVars();
    console.log(val.player);
    var p2_HP = 10;



    function preload() {
      this.load.image('card', 'img/card.png');
      this.load.image('card2', 'img/card2.png');
      this.load.image('cardc01', 'img/c01.png');
      this.load.image('cardc02', 'img/c02.png');
      this.load.image('cardc03', 'img/c03.png');
      this.load.image('cardc04', 'img/c04.png');
      this.load.image('cardc05', 'img/c05.png');
      this.load.image('cardc06', 'img/c06.png');
      this.load.image('cardc07', 'img/c07.png');
      this.load.image('cardc08', 'img/c08.png');
      this.load.image('cardc09', 'img/c09.png');
      this.load.image('cardc10', 'img/c10.png');
      this.load.image('cardc11', 'img/c11.png');
      this.load.image('cardc12', 'img/c12.png');
      this.load.image('cardc13', 'img/c13.png');
      this.load.image('cardd01', 'img/d01.png');
      this.load.image('cardd02', 'img/d02.png');
      this.load.image('cardd03', 'img/d03.png');
      this.load.image('cardd04', 'img/d04.png');
      this.load.image('cardd05', 'img/d05.png');
      this.load.image('cardd06', 'img/d06.png');
      this.load.image('cardd07', 'img/d07.png');
      this.load.image('cardd08', 'img/d08.png');
      this.load.image('cardd09', 'img/d09.png');
      this.load.image('cardd10', 'img/d10.png');
      this.load.image('cardd11', 'img/d11.png');
      this.load.image('cardd12', 'img/d12.png');
      this.load.image('cardd13', 'img/d13.png');
      this.load.image('cardh01', 'img/h01.png');
      this.load.image('cardh02', 'img/h02.png');
      this.load.image('cardh03', 'img/h03.png');
      this.load.image('cardh04', 'img/h04.png');
      this.load.image('cardh05', 'img/h05.png');
      this.load.image('cardh06', 'img/h06.png');
      this.load.image('cardh07', 'img/h07.png');
      this.load.image('cardh08', 'img/h08.png');
      this.load.image('cardh09', 'img/h09.png');
      this.load.image('cardh10', 'img/h10.png');
      this.load.image('cardh11', 'img/h11.png');
      this.load.image('cardh12', 'img/h12.png');
      this.load.image('cardh13', 'img/h13.png');
      this.load.image('cards01', 'img/s01.png');
      this.load.image('cards02', 'img/s02.png');
      this.load.image('cards03', 'img/s03.png');
      this.load.image('cards04', 'img/s04.png');
      this.load.image('cards05', 'img/s05.png');
      this.load.image('cards06', 'img/s06.png');
      this.load.image('cards07', 'img/s07.png');
      this.load.image('cards08', 'img/s08.png');
      this.load.image('cards09', 'img/s09.png');
      this.load.image('cards10', 'img/s10.png');
      this.load.image('cards11', 'img/s11.png');
      this.load.image('cards12', 'img/s12.png');
      this.load.image('cards13', 'img/s13.png');
      this.load.image('slimc11', 'img/slimee.png');
      this.load.image('magic11', 'img/magg.png');
      this.load.image('phsic11', 'img/phss.png');
      this.load.image('flyic11', 'img/flyy.png');
      this.load.image('toric11', 'img/tori.png');
      this.load.image('green', 'img/green.png');
    }

    function copy_array(c1, c2) {
      for (var i = 1; i <= 3; i++) {
        c1[i].ATK = c2[i].ATK;
        c1[i].HP = c2[i].HP;
        c1[i].NAME = c2[i].NAME;
      }
    }//前のやつに後ろのやつを入れる

    function hands_status(i) {
      var str1 = '' + hands[i];
      if (str1.slice(4, 5) == 'c') {
        hands_card[i].ATK = 1;
        hands_card[i].TYPE = "FLY";
      } else if (str1.slice(4, 5) == 'd') {
        hands_card[i].ATK = 2;
        hands_card[i].TYPE = "PHS";
      } else if (str1.slice(4, 5) == 's') {
        hands_card[i].ATK = 3;
        hands_card[i].TYPE = "MAG";
      } else if (str1.slice(4, 5) == 'h') {
        hands_card[i].ATK = 4;
        hands_card[i].TYPE = "SLI";
      }
      hands_card[i].HP = Number(str1.slice(6, 7));
      hands_STAT_TEXT[i].setText(hands_card[i].HP + ":" + hands_card[i].ATK);
      hands_TYPE_TEXT[i].setText(hands_card[i].TYPE);
    }

    function status_card(po) {
      for (var i = 1; i <= 5; i++) {
        hands_STAT_TEXT[i] = po.add.text(-40 + i * 120, height / 8 * 7 + 50, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        hands_TYPE_TEXT[i] = po.add.text(-30 + i * 120 - 25, height / 8 * 7 - 75, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        hands_status(i);
      }
    }//手札のカードの値をカードの下に表示する？？

    function create() {
      objects.camera = this.cameras.add(0, 0, 1600, 800);//どっからどこまでカメラ
      objects.camera.setBackgroundColor('rgba(0,255,0, 0.5)');//背景色を帰れるよ

      var x = 0;

      for (var i = 1; i <= 9; i++) {
        cards[x] = 'cardc0' + i;
        x++;
        cards[x] = 'cardd0' + i;
        x++;
        cards[x] = 'cardh0' + i;
        x++;
        cards[x] = 'cards0' + i;
        x++;
      }//make deck1

      for (var i = 10; i <= 13; i++) {
        cards[x] = 'cardc' + i;
        x++;
        cards[x] = 'cardd' + i;
        x++;
        cards[x] = 'cardh' + i;
        x++;
        cards[x] = 'cards' + i;
        x++;
      }//make deck2

      for (i = 0; i < 53; i++) {
        r = Math.floor(Math.random() * 13 * 4);
        w = cards[i];
        cards[i] = cards[r];
        cards[r] = w;
      }//shuffle

      for (var i = 1; i <= hand; i++) {
        hands[i] = cards[i];
        card = this.add.image(-20 + i * 120, height / 8 * 7, hands[i]);
      }//p1 hand under

      status_card(this);

      for (var i = 1; i <= 3; i++) {
        STAT_TEXT[i] = this.add.text(80 + i * 120, 450, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        TYPE_TEXT[i] = this.add.text(80 + i * 120 - 25, 325, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        field_card[i] = 'slimc11';
        p2_field_card[i] = "slimc11";
        STAT_TEXT[i].setText(ff_card[i].HP + ":" + ff_card[i].ATK);
        TYPE_TEXT[i].setText(ff_card[i].TYPE);
        p2_STAT_TEXT[i] = this.add.text(80 + i * 120, 150, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        p2_TYPE_TEXT[i] = this.add.text(80 + i * 120 - 25, 25, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
        p2_STAT_TEXT[i].setText(p2_ff_card[i].HP + ":" + p2_ff_card[i].ATK);
        p2_TYPE_TEXT[i].setText(p2_ff_card[i].TYPE);
      }//typeと数値を出すp1とp2 場札

      deck = this.add.image(700, height / 8 * 2, 'card');
      text = this.add.text(680, 150, '山札');

      SCText = this.add.text(300, 250, 'SET:' + set).setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      p2_HPText = this.add.text(650, 300, '2P HP:' + p2_HP).setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      HPText = this.add.text(650, 450, '1P HP:' + HP).setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      WINText = this.add.text(450, 250, 'WL').setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      ErrorText = this.add.text(300, 550, 'E').setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      instanText = this.add.text(100, 500, '').setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
    }

    function p2_result(p2_result_data) {
      if (p2_result_data[1].result == 1) {
        if (wins >= 1) {
          wins++;
          WINText.setText('WINS:' + wins);
        } else {
          wins = 1;
          WINText.setText('WIN');
          //resultdbに投げる数字(1);p1が勝つと1,p2が勝つと2 resuletっていう別テーブルを作ってHPと勝ち負けを記録
        }
        p2_HP--;
        updatePlayer("" + 1, HP, 1);
        updatePlayer("" + 2, p2_HP, 2);
        if (p2_HP == 1) {
          ErrorText.setText('YOU WIN');
        }
      } else if (p2_result_data[1].result == 2) {
        WINText.setText('LOSE');
        //resultdbに投げる数字(2);
        if (HP == 1) {
          ErrorText.setText('YOU LOSE');
        }
        HP -= 1;
        updatePlayer("" + 1, HP, 2);
        updatePlayer("" + 2, p2_HP, 1);
      } else {
        WINText.setText('Draw');
        updatePlayer("" + 1, HP, 3);
        updatePlayer("" + 2, p2_HP, 3);
      }
      HP = p2_result_data[1].plyHP;
      p2_HP = p2_result_data[0].plyHP;
      HPText.setText('1P HP' + HP);
      p2_HPText.setText('2P HP' + p2_HP);
    }//p1が勝つとwin,p2が勝つとlose // p2がdataを受け取って表示するためのデータ


    function result(count1, count2) {
      updatePlayer("" + 1, HP, 0);
      updatePlayer("" + 2, p2_HP, 0);
      if (count2 > count1) {
        if (wins >= 1) {
          wins++;
          WINText.setText('WINS:' + wins);
        } else {
          wins = 1;
          WINText.setText('WIN');
        }
        p2_HP--;
        updatePlayer("" + 1, HP, 1);
        updatePlayer("" + 2, p2_HP, 2);
        if (p2_HP == 1) {
          ErrorText.setText('YOU WIN');
        }
      } else if (count1 > count2) {
        WINText.setText('LOSE');
        if (HP == 1) {
          ErrorText.setText('YOU LOSE');
        }
        HP -= 1;
        updatePlayer("" + 1, HP, 2);
        updatePlayer("" + 2, p2_HP, 1);

      } else {
        WINText.setText('Draw');

        updatePlayer("" + 1, HP, 3);
        updatePlayer("" + 2, p2_HP, 3);
      }
      // selectPlayer();
      HPText.setText('1P HP' + HP);
      p2_HPText.setText('2P HP' + p2_HP);
    }



    function print_log_ref() {
      for (var i = 1; i < plog_num; i++) {
        vslog_TEXT[i].setText("");
      }
      plog_num = 0;
    }

    function print_log(po, r1, r2, k, a, c) {
      if (plog_end == 1) {
        print_log_ref();
        plog_end = 0;
      }
      vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
      p2_vslog_TEXT[plog_num] = "p1の" + copy_card[r1].TYPE + "[" + copy_card[r1].HP + ":" + copy_card[r1].ATK + "] VS p2の" + p2_copy_card[r2].TYPE + "[" + p2_copy_card[r2].HP + ":" + p2_copy_card[r2].ATK + "]";
      vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      console.log("****************" + p2_vslog_TEXT[plog_num]);
      plog_num++;
      if (k == 1) {
        vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive().setFill("white");
        p2_vslog_TEXT[plog_num] = "引き分け";
        vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      } else if (k == 2) {
        vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive().setFill("blue");
        p2_vslog_TEXT[plog_num] = "p2の" + p2_copy_card[r2].TYPE + "[" + p2_copy_card[r2].HP + ":" + p2_copy_card[r2].ATK + "]の勝利";
        vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      } else if (k == 3) {
        vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive().setFill("red");
        p2_vslog_TEXT[plog_num] = "p1の" + copy_card[r1].TYPE + "[" + copy_card[r1].HP + ":" + copy_card[r1].ATK + "]の勝利";
        vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
      }
      updateLog(p2_vslog_TEXT);
      plog_num++;
    }//戦闘のログを実際に画面に表示する？

    async function p2_print_log(po) {
      if (plog_end == 1) {
        print_log_ref();
        plog_end = 0;
      }
      if (val.player == 2) {
        p2_vslog_TEXT = (await selectLog()).map(({ log }) => log);
        for (var i = 0; i < 3; i++) {
          vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
          vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
          plog_num++;
          vslog_TEXT[plog_num] = po.add.text(900, height / 8 + 50 * plog_num, "").setFontSize(30).setFontFamily("Arial").setOrigin(0).setInteractive();
          vslog_TEXT[plog_num].setText(p2_vslog_TEXT[plog_num]);
          plog_num++;
        }
      }
    }//戦闘のログを実際に画面に表示する？







    function duel(f, p2_f, p) {
      var cnum = 0;
      while ((count1 != 3 && count2 != 3) && cnum++ != 30) {
        var r1 = Math.floor(Math.random() * 3 + 1);
        var r2 = Math.floor(Math.random() * 3 + 1);
        if (f[r1].HP > 0 && p2_f[r2].HP > 0) {
          console.log("f[" + r1 + "]" + "VS" + "p2_f[" + r2 + "]");
          f[r1].HP -= p2_f[r2].ATK;
          p2_f[r2].HP -= f[r1].ATK;
          if (f[r1].HP <= 0 && p2_f[r2].HP <= 0) {
            console.log("Draw");
            count1++;
            count2++;
            print_log(p, r1, r2, 1, f, p2_f);
          } else {
            if (f[r1].HP <= 0) {
              count1++;//カードが倒されたp1の
              console.log("p2_f[" + r2 + "]の勝利");
              print_log(p, r1, r2, 2, f, p2_f);
            }
            if (p2_f[r2].HP <= 0) {
              count2++;//カードが倒されたp2の
              console.log("f[" + r1 + "]の勝利");
              print_log(p, r1, r2, 3, f, p2_f);
            }
          }
        }
        console.log('count1:' + count1);
        console.log('count2:' + count2);
      }
      result(count1, count2);
    }//p1からp2への戦い一方的
    //今p2の場札1を1.1じゃなくて2.2にしてるよ


    function buff() {
      console.log("もとのやつ:" + ff_card[set].ATK + "," + ff_card[set].HP);
      console.log("足した奴:" + hands_card[hand_num].ATK + "," + hands_card[hand_num].HP);
      ff_card[set].ATK += hands_card[hand_num].ATK;
      ff_card[set].HP += hands_card[hand_num].HP;
      console.log("ATK合計:" + ff_card[set].ATK);
      console.log("HP合計:" + ff_card[set].HP);
    }

    function update() {
      let draw = this.add.text(800, 400, 'Draw').setFontSize(30).setFontFamily("Arial").setOrigin(0.5).setInteractive();
      let end = this.add.text(700, 400, 'End').setFontSize(30).setFontFamily("Arial").setOrigin(0.5).setInteractive();
      let ready = this.add.text(150, 300, 'Instance').setFontSize(30).setFontFamily("Arial").setOrigin(0.5).setInteractive();
      let card1 = this.add.image(100, height / 8 * 7, hands[1]).setOrigin(0.5).setInteractive();
      let card2 = this.add.image(220, height / 8 * 7, hands[2]).setOrigin(0.5).setInteractive();
      let card3 = this.add.image(340, height / 8 * 7, hands[3]).setOrigin(0.5).setInteractive();
      let card4 = this.add.image(460, height / 8 * 7, hands[4]).setOrigin(0.5).setInteractive();
      let card5 = this.add.image(580, height / 8 * 7, hands[5]).setOrigin(0.5).setInteractive();
      var slime1 = this.add.image(-20 + 2 * 120, height / 2, field_card[1]).setInteractive();
      var slime2 = this.add.image(-20 + 3 * 120, height / 2, field_card[2]).setInteractive();
      var slime3 = this.add.image(-20 + 4 * 120, height / 2, field_card[3]).setInteractive();
      let p2_ff_card1 = this.add.image(-20 + 2 * 120, height / 8, p2_field_card[1]).setInteractive();
      let p2_ff_card2 = this.add.image(-20 + 3 * 120, height / 8, p2_field_card[2]).setInteractive();
      let p2_ff_card3 = this.add.image(-20 + 4 * 120, height / 8, p2_field_card[3]).setInteractive();
      SCText.setText('SET:' + set);//出したいカードの場所テキスト
      deck = this.add.image(700, height / 8 * 6, 'card').setInteractive();//山札クリックしてもドローできるよ
      text = this.add.text(680, 550, '山札');



      function p2_stat_update() {
        for (i = 1; i <= 3; i++) {
          p2_STAT_TEXT[i].setText(p2_ff_card[i].HP + ":" + p2_ff_card[i].ATK);
          p2_TYPE_TEXT[i].setText(p2_ff_card[i].TYPE);
        }//p2 dbから帰ってきたようのやつ
      }


      function update_hands(hands, hand, j) {
        for (var i = j; i <= hand; i++) {
          hands[i] = hands[i + 1];
          hands_status(i);
        }
        hands[hand + 1] = "green";
        hands_STAT_TEXT[i].setText("");
        hands_TYPE_TEXT[i].setText("");
        // array_check(hands);
        STAT_TEXT[set].setText(ff_card[set].HP + ":" + ff_card[set].ATK);
        TYPE_TEXT[set].setText(ff_card[set].TYPE);
      }//手札の順番ソート

      function instance(str) {
        j = 1;
        for (var i = 2; i <= 6; i = i + 2) {
          instance_card[j] = ff_card[str.slice(i - 1, i)];
          console.log("strslice" + i + ":" + str.slice(i - 1, i));
          j++;
        }
      }

      function print() {
        for (i = 1; i <= 3; i++) {
          console.log("f1[" + i + ":" + ff_card[i].HP + ":" + ff_card[i].ATK);
          console.log("f2[" + i + ":" + p2_ff_card[i].HP + ":" + p2_ff_card[i].ATK);
          console.log("instance_Card[" + i + "]:" + instance_card[i].HP + ":" + instance_card[i].ATK);
          console.log("p2_instance_Card[" + i + "]:" + p2_instance_card[i].HP + ":" + p2_instance_card[i].ATK);
        }
      }



      function refresh() {
        resetResult("" + val.player);
        ready_flag = 0;
        set_num = "";
        instanText.setText("");
        count1 = 0;
        count2 = 0;
        plog_end = 1;
      }

      function ready_set() {
        if (ready_flag >= 1 && ready_flag < 4) {
          set_num = set_num + " " + set;
          ErrorText.setText("順番:" + set_num);
          ready_flag++;
        } else if (ready_flag >= 4) {
          ready_flag = 1;
          set_num = "";
          ErrorText.setText("順番:" + set_num);
        }
      }

      function TYPE_CHECK(ty, p) {
        if (ty == "MAG") {
          field_card[set] = 'magic11';
          ErrorText.setText('魔法継承しました');
        } else if (ty == "FLY") {
          field_card[set] = 'flyic11';
          ErrorText.setText('飛行継承しました');
        } else if (ty == "PHS") {
          field_card[set] = 'phsic11';
          ErrorText.setText('物理継承しました');
        } else {
          field_card[set] = 'slimc11';
          ErrorText.setText('パワーアップ');
        }
      }

      function card_deal(po) {
        if (set != null && hands[hand_num] != "green") {
          buff();
          ff_card[set].NAME = hands[hand_num];
          ff_card[set].TYPE = hands_card[hand_num].TYPE;
          TYPE_CHECK(ff_card[set].TYPE, po);
          hand--;
          update_hands(hands, hand, hand_num);
          console.log(ff_card[set].TYPE);
        } else {
          ErrorText.setText("場にある継承元を選んでください");
        }
      }

      ready.on('pointerdown', function (pointer) {
        instanText.setText("どれを戦闘に参加させますか？(インスタンス化)");
        ErrorText.setText("順番:" + set_num);
        ready_flag = 1;
      }, this);

      end.on('pointerdown', function (pointer) {
        var k = this;
        console.log("end:" + field_card);
        if (ready_flag != 4) {
          ErrorText.setText("Instanceを押してインスタンス化してください");
        } else {
          instance(set_num);
          console.log("instance_card:" + instance_card);
          print();
          copy_array(copy_card, ff_card);
          copy_array(p2_copy_card, p2_instance_card);
          console.log("p2" + p2_field_card);
          console.log("p1" + instance_card);
          //DBと更新DB上の値が２になるまで待つ関数？
          //ここで相手の場札のカードをp2_field_cardに入れる
          //**insertHandno(hands, "" + val.player, 1);

          //while(end_fin==0){
          //setInterval(function(){
          //endc(this);
          //},1000);
          //}
          //while文で相手のendボタンを待つ
          var pa = this;
          if (val.player == 1) {
            updateField(instance_card, "" + val.player, 1, 1, 1, 1, 1);
            document.getElementById("modal").style.display = "inline";
            var end_fin = setInterval(function () {
              selectHand2();
              if (end111 == 1 && end222 == 1) {
                getP2Hand().then(field_inf => {
                  const p2hand_inf = [null, ...field_inf];
                  copy_array(p2_instance_card, p2hand_inf);
                  document.getElementById("modal").style.display = "none";
                  clearInterval(end_fin);
                  end_fin = 0;
                  if (val.player == 1) {
                    duel(instance_card, p2_instance_card, pa);
                  }
                  copy_array(ff_card, copy_card);
                  copy_array(p2_instance_card, p2_copy_card);
                  refresh();

                });
              }
            }, 1000);
          } else {
            updateField2(instance_card, "" + val.player, 1, 0);
            document.getElementById("modal").style.display = "inline";
            var end_fin = setInterval(async function () {
              const p2_result_data = await selectPlayer();
              //result222=0じゃなくなる関数
              console.log("*********" + p2_result_data);
              if (p2_result_data[1].result != 0) {
                getP1Hand().then(field_inf => {
                  const p1hand_inf = [null, ...field_inf];
                  copy_array(p2_instance_card, p1hand_inf);//p1のハンドコピー
                  document.getElementById("modal").style.display = "none";
                  clearInterval(end_fin);
                  end_fin = 0;
                  p2_print_log(k);
                  p2_result(p2_result_data);
                  //selecthand p1のもってくるやつ
                  copy_array(ff_card, copy_card);
                  copy_array(p2_instance_card, p2_copy_card);
                  refresh();
                });
              }
            }, 1000);
          }

        }
      }, this);

      slime1.on('pointerdown', function (pointer) {
        set = 1;
        ready_set();
      }, this);//場にあるひな形スライムの１個目

      slime2.on('pointerdown', function (pointer) {
        set = 2;
        ready_set();
      }, this);

      slime3.on('pointerdown', function (pointer) {
        set = 3;
        ready_set();
      }, this);

      draw.on('pointerdown', function (pointer) {
        if (hand < 5) {
          hand++;
          dug++;//掘り進めた数
          card6 = this.add.image(-20 + hand * 120, height / 8 * 7, cards[dug]);
          hands[hand] = cards[dug];
          hands_status(hand);
        }
        console.log(field_card[1]);
      }, this);//draw　手札上限五枚で五枚以上はドローできない

      deck.on('pointerdown', function (pointer) {
        if (hand < 5) {
          hand++;
          dug++;//掘り進めた数
          card6 = this.add.image(-20 + hand * 120, height / 8 * 7, cards[dug]);
          hands[hand] = cards[dug];
          hands_status(hand);
        }
        console.log(field_card[1]);
      }, this);//draw　手札上限五枚で五枚以上はドローできない

      card5.on('pointerdown', function (pointer) {
        hand_num = 5;
        card_deal(this);
      }, this);

      card4.on('pointerdown', function (pointer) {
        hand_num = 4;
        card_deal(this);
      }, this);

      card3.on('pointerdown', function (pointer) {
        hand_num = 3;
        card_deal(this);
      }, this);

      card2.on('pointerdown', function (pointer) {
        hand_num = 2;
        card_deal(this);
      }, this);

      card1.on('pointerdown', function (pointer) {
        hand_num = 1;
        card_deal(this);
      }, this);//一番左出す
    }

    function getP1Hand() {
      return new Promise((resolve, reject) => {
        CardPrinter.execute({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
    }

    function getP2Hand() {
      return new Promise((resolve, reject) => {
        CardPrinter.execute2({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
    }

    function selectHand() {
      CardPrinter.execute({
        callback: function (data) {
          $('#error_message').text("");
          //for (var i = 0; i <= 4; i++) {
          //card = po.add.image(100 + i * 120, height / 8, data[i].handno);
          //}
        },
        errorHandler: updateErrorMessage
      });
    }

    function selectHand2() {
      CardPrinter.execute2({
        callback: function (data) {
          $('#error_message').text("");

          end222 = data.some(({ endCheck2 }) => endCheck2 === 1) ? 1 : 0;

          console.log(end222);
        },
        errorHandler: updateErrorMessage
      });
    }

    function selectPlayer() {
      return new Promise((resolve, reject) => {
        CardPrinter.plyexe({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
    }

    function selectLog() {
      return new Promise((resolve, reject) => {
        CardPrinter.logexe({
          callback: data => resolve(data),
          errorHandler: (message, exception) => {
            updateErrorMessage(message, exception);
            reject(exception);
          }
        });
      });
      // CardPrinter.logexe({
      //   callback: function (logdata) {
      //     $('#error_message').text("");

      //     //data.forEach(function (food) {
      //     //  food_text = food_text + "[name]" + food.name + "[price]" + food.price + "<br/>";
      //     //});

      //   },
      //   errorHandler: updateErrorMessage
      // });
    }

    function updateErrorMessage(message, exception) {
      $('#error_message').text(message);
      $('#pprinterReply').text("");
    }

    function updateField(arr, ply, end, res, fly, phs, mag) {
      var field_inf = {
        "id": 1, "player": ply, "endCheck": end, "result": res,
        "HP": [arr[1].HP, arr[2].HP, arr[3].HP],
        "ATK": [arr[1].ATK, arr[2].ATK, arr[3].ATK],
        "TYPE": [arr[1].TYPE, arr[2].TYPE, arr[3].TYPE],
        "fly": fly, "phs": phs, "mag": mag
      };
      end111 = 1;
      CardPrinter.updateField(field_inf, {
        callback: function () {
          console.log("updateField実行完了")
        },
        errorHandler: updateErrorMessage
      });
    }

    function updateField2(arr, ply, end2, res2) {
      var field_inf = {
        "id": 1, "player": ply, "endCheck2": end2, "result2": res2,
        "HP": [arr[1].HP, arr[2].HP, arr[3].HP],
        "ATK": [arr[1].ATK, arr[2].ATK, arr[3].ATK],
        "TYPE": [arr[1].TYPE, arr[2].TYPE, arr[3].TYPE]
      };
      end222 = 1;
      CardPrinter.updateField2(field_inf, {
        callback: function () {
          console.log("updateHand2実行完了");
        },
        errorHandler: updateErrorMessage
      });
    }

    function updatePlayer(ply, plyHP, result) {
      var player_inf = {
        "player": ply, "plyHP": plyHP, "result": result,
      };
      CardPrinter.updatePlayer(player_inf, {
        callback: function () {
          console.log("updatePlayer実行完了");
        },
        errorHandler: updateErrorMessage
      });
    }

    function updateLog(log) {
      var log_inf = {
        "logid": 1, "log": [log[0], log[1], log[2], log[3], log[4], log[5]]
      };
      CardPrinter.updateLog(log_inf, {
        callback: function () {
          console.log("updateLog実行完了");
        },
        errorHandler: updateErrorMessage
      });
    }

    function resetResult(ply) {
      var reset_inf = {
        "player": ply, "endCheck": 0, "result": 0
      };
      CardPrinter.resetResult(reset_inf, {
        callback: function () {
          console.log("resetResult実行完了")
        },
        errorHandler: updateErrorMessage
      });
      CardPrinter.resetResult2(reset_inf, {
        callback: function () {
          console.log("resetResult2実行完了")
        },
        errorHandler: updateErrorMessage
      });
      end111 = 0;
      end222 = 0;
    }

  </script>


</body>

</html>
